<style>
.element {
  width: 10vh;
  height: 10vh;
  border-radius: 2vh;
  position: relative;
  left:2.5vh;
  text-align: center;
  vertical-align: middle;
}

.row {
  width: 100vw;
  padding: 1vh;
}

.movable {
  position: absolute !important;
}

.fixed {
  margin-right: 1vh;
}
</style>

<div class="main" style="scroll: overflow;">
    <div :style='"background-color:" + c.SelectedColor + "; color: " + c.CalcColor(c.SelectedColor)' vg-content="c.Selected.Name" class="element movable" id="elem" vg-if="c.Showing"></div>

    <span vg-if="!c.Init" vg-content='c.Initialize()'>Loading...</span>

    <div class="row" vg-for="colInd, color := range c.Colors">
      <div vg-for="_, element := range (*c.Elements)" :style='"background-color:" + color + "; color: " + c.CalcColor(color)' vg-content="element.Name" vg-if="colInd == element.Color && c.IsFound(element.Index)" class="element fixed" @click="c.Show(element, color)"></div>
    </div>

    <div class="modal fade" id="suggestModal" tabindex="-1" aria-labelledby="suggestModalLabel" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="suggestModalLabel">New Suggestion</h5>
            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
              <span aria-hidden="true">&times;</span>
            </button>
          </div>
          <div class="modal-body">
            IN PROGRESS
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-muted" data-dismiss="modal">Close</button>
            <button type="button" class="btn btn-secondary" @click="c.Mode = !c.Mode; c.OpenModal(true)"><span vg-if="!c.Mode">Make your own element</span><span vg-if="c.Mode">Vote for element</span></button>
            <button type="button" class="btn btn-primary" @click="c.MakeSuggestion(); c.OpenModal(true)" @click="c.Suggest()"><span vg-if="!c.Mode">Vote</span><span vg-if="c.Mode">Send Suggestion</span></button>
          </div>
        </div>
      </div>
    </div>

	  <div style="width: 100vw; height: 100vh; position: fixed; top: 0; left:0; bottom:0; right:0; z-index:-100;" @click="c.Showing = false"></div>
</div>

<script type="application/x-go">
type Elemental struct {
    Init bool `vugu:"data"`
	  Showing bool `vugu:"data"`
    Elements *[]Element `vugu:"data"`
    Found *[]int `vugu:"data"`
    Colors []string `vugu:"data"`
    Selected Element `vugu:"data"`
    SelectedColor string `vugu:"data"`
    Handle func(error)
    FoundElement func([]int)
    SuggestDisabled *bool
    SuggestElement *func(vugu.EventEnv, Suggestion)
    Suggestion Suggestion
    Username *string
    Mode bool `vugu:"data"`
}

func (c *Elemental) Initialize() string {
	move := func(this Value, inputs []Value) interface{} {
		if c.Showing {
			document := Global().Get("document")
			e := inputs[0]
			document.Call("getElementById", "elem").Get("style").Set("left", fmt.Sprintf("%dpx", e.Get("clientX").Int()))
			document.Call("getElementById", "elem").Get("style").Set("top", fmt.Sprintf("%dpx", e.Get("clientY").Int()))
		}
		return ""
	}
	jsFunc := FuncOf(move)
	c.Init = true
	Global().Get("document").Set("onmousemove", jsFunc)
	return ""
}

func (c *Elemental) CalcColor(bg string) string {
  bgColor := bg[1:len(bg)]
  rgb, err := hex.DecodeString(bgColor)
  c.Handle(err)
  average := (int(rgb[0]) + int(rgb[1]) + int(rgb[2])) / 3
  if average < 127 {
    return "#ffffff"
  }
  return "#000000"
}

func (c *Elemental) Show(elem Element, color string) {
  if !c.Showing {
    c.Showing = true
    c.Selected = elem
    c.SelectedColor = color
    (*c.SuggestDisabled) = true
  } else {
    var first Element
    var second Element
    if elem.Index < c.Selected.Index {
      first = elem
      second = c.Selected
    } else {
      first = c.Selected
      second = elem
    }
    _, has_product := first.Products[second.Index]
    if has_product && (!c.IsFound(first.Products[second.Index])) {
      (*c.Found) = append((*c.Found), first.Products[second.Index])
      sort.Ints(*c.Found)
      c.FoundElement(*c.Found)
    } else if !has_product{
      c.Showing = false
      c.Suggestion = Suggestion{
        NewElement: Element {
          Name: "Element Name Goes Here...",
          Creator: "",
          Products: make(map[int]int, 0),
          Color: first.Color,
          Index: -1,
          Created: "",
        },
        Producer: [2]int{first.Index, second.Index},
        Votes: 0,
      }
      (*c.SuggestDisabled) = false
    }
    c.Showing = false
  }
}

func (c *Elemental) IsFound(index int) bool {
  if len(*c.Found) > 0 {
    item := sort.SearchInts(*c.Found, index)
    if item < len(*c.Found) {
      return true
    } else {
      return false
    }
  }
  return false
}

func (c *Elemental) MakeSuggestion() {
  fmt.Println(c.Suggestion)
}

func (c *Elemental) OpenModal(retoggle bool) {
  if !retoggle {
    time.Sleep(time.Second/2)
  }
  Global().Call("jQuery", "#suggestModal").Call("modal", "toggle")
  if retoggle {
    go c.OpenModal(false)
  }
}

func (c *Elemental) Suggest() {
  fmt.Println("Suggestion")
}
</script>